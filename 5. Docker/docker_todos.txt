docker run -d -p 8080:80 nginx
    # -d means run in detached mode, in background,
    # we don't have control of terminal of running container

    # -p is for port mapping
    # it map port between of your local machine and the container
    # 8080:80 attach port 80 of container to our local port 8080
    # so that all the things running on port 80 of container, is accessible from port
    # 8080 of our local

    # if we go to localhost:8080 on our local, we can see nginx is running.
    # nginx listen to port 80 by default

docker commits:
    - Docker commits create new images from container changes - think of them as 
      "saving" the current state of a container as a reusable image.
    - when you run container and make some changes inside it,
      for ex. install new software or change some files
    - then those changes only exist in that running container. If you stop and remove 
      the container, the changes are lost.
    - docker commits capture those images and create new image that include them.

    syntax:
    docker commit [option] "message" [container_id] [new image name:version]

    ex. 
        docker commit -m "added file name.txt" [container_id] name_ubuntu:1.0

        # now if we do docker images.   
          we can see name_ubuntu image

        # we can run name_ubuntu image
          docker run -it name_ubuntu:1.0

start container:
    docker start [container_id]

    copy container id from docker ps -a command

docker exec : 
    Docker exec runs commands inside already running containers

    syntax : docker exec [options] [container-name/id] [command]

    ex. docker exec -it [container_id] bash
        # Get a bash shell inside a running container

Removing all the images:
    1. docker images -q             # give only image id of all images
    2. docker rmi $(docker images -q)

layers:
    Multiple image can share some common layers.
    so that if some of the layers are present then it reduce space by reuse them.

    ex. 
    docker run ubuntu:16.04         # run ubuntu image.
    docker image                    # we can see some character of image id
    docker inspect      # here we can see that 

         "Layers": [
                "sha256:be96a3f634de79f523f07c7e4e0216c28af45eb5776e7a6238a2392f71e01069",
                "sha256:df54c846128da3c71cc11b2150a3df39ec86fb170e299765daf6bb016a0705c2",
                "sha256:47ef83afae74745639f6738a05fe5320fcfca9e6c7765fba4f25e270bc0df9dc",
                "sha256:1251204ef8fc20da275e09f6e3ab9205421d4ff34732f2d50a1d3e86d2995edd"
            ]

    - so if any of this layer exist in other image then while downloading other image
      it take layer from here