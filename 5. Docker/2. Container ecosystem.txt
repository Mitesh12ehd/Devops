
    1. Runtime: 
        - it allows us to start and stop container

        runc:
            - it interact with os to create containers
            - manages container life cycle (start, stop, pause, resume)

        containerd: 
            - manages runc
            - high-level container runtime to manage container
            - it do stuff like how container interact with network
            - how to get data from internet (ex. pulling the images from registry)

        Problem: 
            - There are so many container runtime.
                ex. runc, containerd, lxc, rocket rkt, crio
            - This created fragmentation where containers built for one platform 
               wouldn't necessarily work on another, leading to vendor lock-in
            - Without common standards, developers had to choose between competing 
              container technologies, and there was no guarantee of portability 
              between different container engines or orchestration platforms.

        Solution:
            OCI : open container initiative
            - it design open standards for containers

            - Kubernetes follow CRI(container runtime interface), and docker is open
              container initiative(OCI). but Kubernetes say any OCI compliant image
              will look same to kubernetes.


    2. Engine: 
        - The container engine is the user-facing management layer that provides the 
          tools, APIs, and interfaces for working with containers.

        ex. docker Daemon (dockerd) :
            - it is is a background service that manages Docker objects like images, 
              containers, networks, and volumes

    3. Orchestration:
        - Container orchestration operates at the cluster level, managing multiple 
          containers across multiple hosts.
        - Kubernetes is the dominant orchestration platform, though Docker Swarm and Apache Mesos are 
          alternatives.

        - helps in cases like
            1. we want to increase our application version for each container running
            2. if some of the container stopped, then rerun the stopped container
